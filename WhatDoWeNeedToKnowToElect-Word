 [T]	Title:  Analysis and modification of leader election algorithms in networks with unknown participants.
[A]	Abstract: A network with unknown participants is simply a network where the processes have very basic knowledge of the system.  Nodes in the network do not necessarily know every node participating in the network and  they will only have a subset of the total amount of nodes in which they will know about and be able to communicate directly with.  This type of network is "contact list" like, where during initial communication one can communicate with an unknown neighbour only if one has been first contacted by this neighbour (creating a communication path).  In this report we investigate the Leader Election problem in general networks with unknown participants.   Since Leader Election is a useful benchmark for computability investigations in distributed computing, this report can outline what else is solvable in networks that also contain unknown participants.  
Throughout this paper we will be analyzing, modifying and measuring different algorithms found in the research paper [JEA14].  Among these modifications will be changes to the reach algorithm.  We will see if these changes affect the time to complete, which algorithm is faster (and by how much), if it is even possible to complete computations with a modified algorithm, and if not why.  Our plan takes away the necessary and sufficient requirement from the original paper after our modifications.  This may cause a leader to be elected without asking every node in the network first, this is a problem because the algorithm may then create multiple leaders.

[I]	Introduction: Distributed systems are spreading throughout all of computer science and recently more interest has been in studying more dynamic systems.   There have not been many studies on static models where the local connectivity evolves in a light way during the computation.  
Consider a set of participants that communicate with phones.  Initially, each person (node) knows a subset (contact list) of the total amount of other people in the phone registry.  This subset each node has includes everyone the node knows about including the people that do not know specifically about this node.  So for example, Frank may have Ferns number, and Fern may not know Franks number.  In this situation Frank can contact Fern, but Fern cannot communicate with Frank until first receiving a message from frank.  Fern will not even know of Franks phone possession (existence in network) until first being contacted by Frank.  During the preliminary stages of this phone network connectivity is low, it is also directed, and adjacency between nodes increases over time from computations by the network (people adding each other on contact lists).  This system is asynchronous.
In an arbitrary network, the underlying communication graph is an undirected graph denoted by G.  Nodes each have identities, and communicate with messages.  Initially a node can send messages only to a subset of its actual neighbours in G.  This defines the first directed graph G⁰, the contact list of neighbours will be extended whenever a message is received from an "unknown" in-member.  At the end of computation, the possible communication graph corresponds to G, G is the undirected version of the initial digraph G⁰.  The network is reliable, but asynchronous so the messages will always be delivered but unpredictable delays. 
Related Work. The network with unknown participants model presented here is a slight variation of a model that has been formally introduced and studied in [JEA14]. In [JEA14] there exists a necessary and sufficient condition that states if we have isolated executions, we might get more than one processes elected.  So there is a condition that enables to somehow forbid disjoint isolated executions.  In our modified election algorithm we no longer have this condition and therefore may finish executions faster, or may create the problem the conditions exists to prevent.

[M]	The Model:  
	Message passing model:  A network is defined by a directed graph G, where V(G) is the set of processes, and E(G) is the set of communication channels.  Processes communicate by sending and receiving messages via some ports.   The communication channels linking between ports are asynchronous and are of different distances, so they will compute in time relative to their distance from each other.
	Processes identities.  Each process v is given a unique label which is the identity of the process.   As there are several such labelling for a same graph (permutation, remaining), we consider all of them using an injective function idG : V→N giving a unique identity to every process.  Each process must be given a unique identity in order to preserve it isolation from other processes.
	Port labelling.  Each process v can address its different neighbours using a bijective port numbering function δv : V → N giving a unique number to every port of v.  When v receives a message from a neighbour w, it receives the message through the port  δv(w).  Where the port contains a contact list of possible neighbours that it knows about and builds this list as time goes on.
	Graph labelling.  The state of each process is represented by a label λ(v) associated to the corresponding vertex v ∈ V (G). Note that λ(v) initially contains the identity of v and its known neighbours list contacts v cited above. Let G = (G, λ), such a labelled graph. For all arcs (u, v) ∈ E(G), let B(u, v) be the queue containing the messages in transit from u to v. Initially, B(u, v) is empty for all arcs (u, v).
	Distributed Algorithm.  A distributed algorithm is a set of state transition rules. Such transition rules are function of the current local state of the system. In our setting, three kinds of transitions are possible for a process v: it can modify its state, it can receive a message from a neighbour or it can send a message to all its known neighbours.  If a neighbour is not known when contacted by one, v updates contacts with the new list of the neighbours it knows.  When v sends a message m0 , it sends the same message to all its known neighbours using a primitive SendAll.  This type of message passing floods the network of nodes with messages communicating to all nodes on the current contact lists.  Below will be an example in an arbitrary network that started with five nodes where communication started as only one way communication, and the second image will be after a few rounds of communication to see how the contact list has been built from the initial graph after some communication rounds.  
A distributed algorithm A in the message passing model is a set of algorithms (Av)v∈V (G) distributed over the nodes of the network. A transition of the algorithm is a transition of a process v according to its local algorithm Av. 
	Execution Representation. An execution ρ of a distributed algorithm A is a sequence of changes on vertices state. An execution is represented by a sequence of couples [(λ0 , B0 ),(λ1 , B1 ), ...,(λn,  Bn)]ρ where, at step i, λi is the state of the system and Bi , the set of messages in transit. Let λIv , the state of vertex v at step i. The initial state λ0v is the state of process v before the execution. A transition from step i to step i+ 1 is performed by one and only one process which executes a transition cited above in its local algorithm. This transition leads to the next state of v: λi+1v and Bi+1 and all other processes keep the same state as in λi . Note that any asynchronous execution (including the synchronous execution) can be represented this way. 
	Algorithm Properties. An execution stabilises if there is a step i0 where no process can progress in its local algorithm and no message is in transit. In an execution, a process v decides if it eventually writes a value in out and if it does it only once during the execution. An execution terminates if it stabilises and if every process decides. An algorithm terminates on (G, λin) with if every execution of the algorithm on (G, λin) terminates. In an execution ρ that terminates, each process v has an output value outv !=⊥; in this case, we say that outv is the final label of v in ρ. Let S be the specification of a problem. An execution ρ of A in a graph (G, λin) ∈ Gin satisfies the Correction Property if ρ terminates and (G, λout), the final labelling computed by ρ satisfies (G, λin)S(G, λout). An algorithm A is valid for a specification S in a graph (G, λin) ∈ Gin if every execution ρ satisfies the Correction Property. We will say that A solves S on (G, λin) in such a case. 
	Knowledge. As we will see, some problems need additional global information or knowledge to be solved. This information about the underlying network (e.g. a bound on the size of the system) is inserted in the initial label. Consider a function κ that encodes an arbitrary knowledge. An algorithm A solves S with knowledge κ, if for all G, A solves S on (G, κ(G)). Equivalently we have that, for any α ∈ κ −1 (Gid), there exists an algorithm Aα that solves S on the family F = κ −1 (α). Solving a problem with partial knowledge is simply, for any possible value α of knowledge, solving the problem within the family of networks whose knowledge value is α. Considering arbitrary families of labelled graphs enables to represent any initial knowledge: e.g. if the processes initially know the size n of the network, then in the corresponding family F (n) , for each G ∈ F(n) and each v ∈ V (G), n = |V (G)| is a component of the initial label of v.
	Remains Universal.  A universal algorithm is one that will work for what it is intended to work on, regardless of input.  For example if there is a graph and the number of nodes is desired to be found, an algorithm can be created so that every node is counted no matter what shape or size of graph it is.  On the other hand an algorithm that is not universal would not work for any size graph or any shape of graph, there will be limitations to it that cause it to not always work.

[B]	Body:
	[E] 	Experiments:
We are beginning with the reach algorithm outlined in [JEA14], we will be modifying this algorithm to examine if it can be improved, or done another way with the same result.  
To start with we will add distance to the random graphs generated for testing.  These graphs with distance will be compared for completion time with the original graphs.  To do this an average sample of completions must be taken in order to eliminate the variance between random generations.  A sample of 20 random graphs has been chosen to represent the population for each test, 20 should be a large enough sample size to get a more accurate/reasonable average outcome for running time.  
Each graph will contain a specific number of nodes per test, the first set of 20 tests will be run on simply 4 nodes in the graph.  When the 20 tests have been completed and times recorded, the same test will be applied to the original graphs and the average can then be compared for a graph of size 4 for a basis.
Next the nodes of the graph will be increased to a number of 8, and the time test will then be run the same way as it was for when there were 4 nodes.  When all the times and averages are calculated for both new and original graphs the averages can be compared again.  An upper limit of time will be instilled to prevent an impossibility result never ending the executions.  Finally the timed tests will be run on graphs with nodes numbering 12 and then compared, Analyzing the data and providing the statistics will continue in the rest of the body of this report.
	[D]	Discussion:
	[R]	Results:
	[P]	Proof:
	[T]	Theorems:
	[M]	Methodology:
	[F]	Figures:
	[Ta]	Tables:
	[Di]	Diagrams
 
Leader election, unknown neighbours 1		      |  Leader election, unknown neighbours 2
  
Leader election, unknown neighbours 3		      |  Leader election, unknown neighbours 4
  
Leader election, unknown neighbours 5		      |  Leader election, unknown neighbours 6

[C]	Conclusion:
	Through thorough testing we can conclude that distance (andfpisndpfn) the time to complete the leader election algorithm.  
While working on problems like these an observer may ask the question, what is the point?  To this a proper response can include the fact that most online games that require active hosts to serve the game to the other players require some sort of leader election algorithm.  Each time a game is initialized a host must be chosen to match requirements of being the leader, and if their connection is abolished, another node in the network must take its place as the leader.

References

[JEA14]  Jérémie Chalopin, Emmanuel Godard and Antoine Naudin. What Do We Need to Know to Elect 	in Networks with Unknown Participants?.  In SIROCCO 2014, page 279-294.


