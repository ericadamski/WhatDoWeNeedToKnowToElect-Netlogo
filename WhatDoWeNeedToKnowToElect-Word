 [T]	Title:  Analysis of leader election algorithms in networks with unknown participants.
[A]	Abstract: A network with unknown participants is simply a network where the processes have very basic knowledge of the system.  Nodes in the network do not necessarily know every node participating in the network and  they will only have a subset of the total amount of nodes in which they will know about and be able to communicate directly with.  This type of network is "contact list" like, where during initial communication one can communicate with an unknown neighbour only if one has been first contacted by this neighbour (creating a communication path).  In this report we investigate the Leader Election problem in general networks with unknown participants.   Since Leader Election is a useful benchmark for computability investigations in distributed computing, this report can outline what else is solvable in networks that also contain unknown participants.  
Throughout this paper we will be analyzing and measuring different algorithms found in the research paper [JEA14].  We will see if it is even possible to complete computations with a algorithm in the original paper, and if not why.  Our purpose to this report is to provide an analysis of the reach algorithm, in particular the runtime.  The way the algorithm has been simulated may cause a leader to be elected without asking every node in the network first, this is a problem because the algorithm may then create multiple leaders.

[I]	Introduction: Distributed systems are spreading throughout all of computer science and recently more interest has been in studying more dynamic systems.   There have not been many studies on static models where the local connectivity evolves in a light way during the computation.  
Consider a set of participants that communicate with phones.  Initially, each person (node) knows a subset (contact list) of the total amount of other people in the phone registry.  This subset each node has includes everyone the node knows about including the people that do not know specifically about this node.  So for example, Frank may have Ferns number, and Fern may not know Franks number.  In this situation Frank can contact Fern, but Fern cannot communicate with Frank until first receiving a message from frank.  Fern will not even know of Franks phone possession (existence in network) until first being contacted by Frank.  During the preliminary stages of this phone network connectivity is low, it is also directed, and adjacency between nodes increases over time from computations by the network (people adding each other on contact lists).  This system is asynchronous.
In an arbitrary network, the underlying communication graph is an undirected graph denoted by G.  Nodes each have identities, and communicate with messages.  Initially a node can send messages only to a subset of its actual neighbours in G.  This defines the first directed graph G⁰, the contact list of neighbours will be extended whenever a message is received from an "unknown" in-member.  At the end of computation, the possible communication graph corresponds to G, G is the undirected version of the initial digraph G⁰.  The network is reliable, but asynchronous so the messages will always be delivered but unpredictable delays. 
Related Work. The network with unknown participants model presented here is a slight variation of a model that has been formally introduced and studied in [JEA14]. In [JEA14] there exists a necessary and sufficient condition that states if we have isolated executions, we might get more than one processes elected.  So there is a condition that enables to somehow forbid disjoint isolated executions.  In our modified election algorithm we no longer have this condition and therefore may finish executions faster, or may create the problem the conditions exists to prevent.

[M]	The Model:  
	Message passing model:   Processes communicate by sending and receiving messages over a restricted subset of the network.   The edges of the network that link the vertices are asynchronous and are of different distances, so they will compute in time relative to their distance from each other.
	Processes identities.  Each process must be given a unique identity in order to preserve its isolation from other processes.  If two processes were to have the same identity the leader election algorithm could possibly elect both vertices to be the leader.
	Port labelling.  Each vertex of the graph will have a contact list of its known neighbours which is a subset of all nodes in the network.  Each node will have certain ports that accept messages, when a node v receives a message from a neighbour w, it receives the message through the port labelled w.  If a port contains a contact list of possible neighbours and receives a message from a neighbour that it does not know, it updates this list with the newly learned neighbours as time goes on.
	Graph labelling.  Initially the graph contains an amount of nodes that each know about one of their neighbours (their contact list), and themselves.  The queue containing the messages in transit between all edges between nodes will begin as empty.
	Distributed Algorithm.  A distributed algorithm is a set of state transition rules. Such transition rules are function of the current local state of the system. In our setting, three kinds of transitions are possible for a process v: it can modify its state, it can receive a message from a neighbour or it can send a message to all its known neighbours [JEA14].  If a neighbour is not known when contacted by one, v updates contacts with the new list of the neighbours it knows.  When a node sends a message, it sends the same message to all of its known neighbours using a send all function.  This type of message passing floods the network of nodes with messages communicating to all nodes on the current contact lists this grows the contact lists and more communication is initiated.  Each node is essentially reaching to the other nodes through neighbours it knows.  Below will be an example in an arbitrary network that started with five nodes where communication started as only one way communication, the second image will be after a few rounds of communication to see how the contact list has been built from the initial graph.  
	Execution Representation. An execution of a leader election algorithm is a sequence of changes on vertices state within the graph.  The nodes all start in a state of being inactive and with an unknown leader status.  After execution of communication rounds there is knowledge built in the network which allows each node to decide if it should be a leader or not.  After sufficient knowledge is built a node will decide that it should not be a leader so it will change its state to resemble this knowledge.  At the end of electing a leader, each node must have their status checked to make sure that no node was skipped during a computation process.
	Algorithm Properties. An execution finishes when there is no progress that can be made in a nodes local algorithm and no message is in transit. In an execution, a process decides if it eventually writes a value out and if it does it only does once during the execution. Execution ends if every process decides what it needs to set its state as. 
	Knowledge. As we will see, some problems need additional global information or knowledge to be solved. This information about the underlying network (e.g. a bound on the size of the system) is inserted in the initial label. Consider a function κ that encodes an arbitrary knowledge. An algorithm A solves S with knowledge κ, if for all G, A solves S on (G, κ(G)). Equivalently we have that, for any α ∈ κ −1 (Gid), there exists an algorithm Aα that solves S on the family F = κ −1 (α). Solving a problem with partial knowledge is simply, for any possible value α of knowledge, solving the problem within the family of networks whose knowledge value is α. Considering arbitrary families of labelled graphs enables to represent any initial knowledge: e.g. if the processes initially know the size n of the network, then in the corresponding family F (n) , for each G ∈ F(n) and each v ∈ V (G), n = |V (G)| is a component of the initial label of v.
	Remains Universal.  A universal algorithm is one that will work for what it is intended to work on, regardless of input.  For example if there is a graph and the number of nodes is desired to be found, an algorithm can be created so that every node is counted no matter what shape or size of graph it is.  On the other hand an algorithm that is not universal would not work for any size graph or any shape of graph, there will be limitations to it that cause it to not always work.

[B]	Body:
	[E] 	Experiments:
We are beginning with the reach algorithm outlined in [JEA14], we will be analyzing this algorithm to examine if it can be improved, and how long it takes.  
To analyze the leader election algorithm an average sample of completions must be taken in order to eliminate the variance between random generations.  A sample of 10 random graphs has been chosen to represent the population for each test, 10 should be a large enough sample size to get a more accurate/reasonable average outcome for running time.  
Each graph will contain a specific number of nodes per test, the first set of 10 tests will be run on simply 2 nodes in the graph.  When the 10 tests have been completed and times recorded, the average can then be compared for a graph of size 3 for a so we can find a correlation between node amount and time to complete.
Next the nodes of the graph will be increased to a number of 4, and the time test will then be run the same way as it was for when there were 3 nodes.  When all the times and averages are calculated for the graphs the averages can be compared again.  Finally the timed tests will be run on graphs with nodes numbering 10 and then compared with a theorized time expected to see how well our analysis was on the same graphs of smaller size.  This is to see if we can predict a runtime of a network with any amount of nodes.  Analyzing the data and providing the statistics will continue in the rest of the body of this report.
	[D]	Discussion:	For the network that we have been working with, each node has unknown neighbours.  In order for us to actually simulate how the leader election algorithm would work with unknown neighbours we made it so that every node knows number of vertices in the network so that it does not send infinite messages every round of communication.  This is a bit of an issue as this does not take into account extra time and extra message complexity, as well as the possibility of errors.  In our case we assume there will be no errors that occur to limit the variability in our results. 
Each node will send at least one message to all nodes in the network.  The receiving is the hard part, each time a node receives a message they change their state and have to inform everyone else of this change, which is why the number of messages received is what affects the runtime and message count largely. 


	[R]	Results:  It turns out that in a graph with only two nodes there is no variability in the amount of messages, only in the amount of communication rounds needed to complete the leader election.  The reason we know there will only ever be eight messages sent in a two node graph is because there is no variability in how the graph is arranged.  The distances between nodes, nodes will be in different positions, but in every iteration there will be one node that knows about the other and the other node will not know any until after the first round of communication. So in every arrangement the same variables are present other than which node is qualified to be the leader.
Also on a network with two nodes each node can only send one message per tick, each communication round will consist of only two messages.  When one node has decided not to be the leader, then one message and one response message will be sent to make sure that the other remaining node should be the one that will become the leader.

	[P]	Proof:
	[T]	Theorems: 
The runtime might change depending on when the leader is elected.  The runtime is typically longer when the leader is the last node to be coloured, this is thought to happen because each node will have already decided that it will not be the leader, but each one must decide again after the leader has been elected.
Worst case scenario one guy points to all other nodes in the graph, and no one points to it.  All the other nodes decide that they are not the leader, and the one that was pointing to them all becomes the leader.

	[M]	Methodology:
	[F]	Figures:
	[Ta]	Tables:
	
# of nodes	# of messages	Time
2	8	6 Ticks
2	8	4 Ticks
2	8	5 Ticks
2	8	4 Ticks
2	8	6 Ticks
2	8	5 Ticks
2	8	5 Ticks
2	8	5 Ticks
2	8	5 Ticks
Statistics	
Mean = 8
Median = 8
Standard d = 0	
		Mean = 5
		Median = 5
		Standard d = 0.6667
		
# of nodes	# of messages	Time
3	49	22 Ticks
3	56	25 Ticks
3	52	23 Ticks
3	48	23 Ticks
3	40	20 Ticks
3	43	20 Ticks
3	39	19 Ticks
3	51	24 Ticks
3	49	22 TIcks
Statistics
Mean = 47.44
Median = 49
Standard d = 5.681	
		Mean = 22
		Median = 22
		Standard d = 2
		
# of nodes	# of messages	Time
5	616	162 Ticks
5	312	147 Ticks
5	610	218 Ticks
5	536	197 Ticks
5	578	213 Ticks
5	415	147 Ticks
5	474	170 Ticks
5	596	154 Ticks
5	559	143 Ticks
Statistics
Mean = 521.78
Median = 559
Standard d = 102.84

		Mean = 173.33
		Median = 162
		Standard d = 29.453


# of nodes	# of messages	Time
4	202	67 Ticks
4	184	82 Ticks
4	202	67 Ticks
4	128	44 Ticks
4	128	44 Ticks
4	184	82 Ticks
4	211	70 Ticks
4	213	71 Ticks
4	130	61 Ticks
Statistics
Mean = 175.78
Median = 184
Standard d = 36.738
		Mean = 65.33
		Median = 67
		Standard d = 13.89 

[Di]	Diagrams
 
Leader election, unknown neighbours 1		      |  Leader election, unknown neighbours 2
  
Leader election, unknown neighbours 3		      |  Leader election, unknown neighbours 4
  
Leader election, unknown neighbours 5		      |  Leader election, unknown neighbours 6

[C]	Conclusion:
	This may not be the most efficient algorithm, but it works.  For small networks of nodes this algorithm can complete in a relatively short amount of time.  Growing the network to a size more than ten nodes comes with a large wait for completion.  During our testing we had tested a fifteen node network, after six hours it had not even reached the highest amplitude of active messages (as it was still going up) which as seen in the diagrams above displaying a five node network the amplitude is only about at 25-30% of the total time the algorithm took to elect a leader. 
References

[JEA14]  Jérémie Chalopin, Emmanuel Godard and Antoine Naudin. What Do We Need to Know to Elect 	in Networks with Unknown Participants?.  In SIROCCO 2014, page 279-294.


