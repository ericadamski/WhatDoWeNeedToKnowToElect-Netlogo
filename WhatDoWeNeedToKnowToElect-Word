

Tell me what you think about the title i chose.


[T]	Title:  Analysis and modification of leader election algorithms in networks with unknown particiants.
[A]	Abstract: A network with unknown participants is simply a network where the processes have very basic knowledge of the system.  Nodes in the network do not necessarily know every node participating in the network and  they will only have a subset of the total amount of nodes in which they will know about and be able to communicate directly with.  This type of network is "contact list" like, where during initial communication one can communicate with an unknown neighbour only if one has been first contacted by this neighbour (creating a communication path).  In this report we investigate the Leader Election problem in general networks with unknown participants.   Since Leader Election is a useful benchmark for computability investigations in distributed computing, this report can outline what else is solvable in networks that also contain unknown participants.  
Throughout this paper we will be analyzing, modifying and measuring different algorithms found in the research paper [JEA14].  Among these modifications will be changes to the reach algorithm.  We will see if these changes affect the time to complete, which algorithm is faster (and by how much), if it is even possible to complete computations with a modified algorithm, and if not why.  Our plan takes away the necessary and sufficient requirement from the original paper after our modifications.  This may cause a leader to be elected without asking every node in the network first, this is a problem because the algorithm may then create multiple leaders.

[I]	Introduction: Distributed systems are spreading throughout all of computer science and recently more interest has been in studying more dynamic systems.   There have not been many studies on static models where the local connectivity evolves in a light way during the computation.  
Consider a set of participants that communicate with phones.  Initially, each person (node) knows a subset (contact list) of the total amount of other people in the phone registry.  This subset each node has includes everyone the node knows about including the people that do not know specifically about this node.  So for example, Frank may have Ferns number, and Fern may not know Franks number.  In this situation Frank can contact Fern, but Fern cannot communicate with Frank until first receiving a message from frank.  Fern will not even know of Franks phone possession (existence in network) until first being contacted by Frank.  During the preliminary stages of this phone network connectivity is low, it is also directed, and adjacency between nodes increases over time from computations by the network (people adding each other on contact lists).  This system is asynchronous.
In an arbitrary network, the underlying communication graph is an undirected graph denoted by G.  Nodes each have identities, and communicate with messages.  Initially a node can send messages only to a subset of its actual neighbours in G.  This defines the first directed graph G⁰, the contact list of neighbours will be extended whenever a message is received from an "unknown" in-member.  At the end of computation, the possible communication graph corresponds to G, G is the undirected version of the initial digraph G⁰.  The network is reliable, but asynchronous so the messages will always be delivered but unpredictable delays. 
Related Work. The network with unknown participants model presented here is a slight variation of a model that has been formally introduced and studied in [JEA14]. In [JEA14] there exists a necessary and sufficient condition that states if we have isolated executions, we might get more than one processes elected.  So there is a condition that enables to somehow forbid disjoint isolated executions.  In our modified election algorithm we no longer have this condition and therefore may finish executions faster, or may create the problem the conditions exists to prevent.

[M]	The Model:  
	Message passing model:  A network is defined by a directed graph G, where V(G) is the set of processes, and E(G) is the set of communication channels.  Processes communicate by sending and receiving messages via some ports.   The communication channels linking between ports are asynchronous and are of different distances, so they will compute in time relative to their distance from each other.
	Processes identities.  Each process v is given a unique label which is the identity of the process.   As there are several such labelling for a same graph (permutation, remaining), we consider all of them using an injective function idG : V→N giving a unique identity to every process.  Each process must be given a unique identity in order to preserve it isolation from other processes.
	Port labelling.  Each process v can address its different neighbours using a bijective port numbering function δv : V → N giving a unique number to every port of v.  When v receives a message from a neighbour w, it receives the message through the port  δv(w).  Where the port contains a contact list of possible neighbours that it knows about and builds this list as time goes on.
	Graph labelling.  
	Distributed Algorithm.
	Execution Representation.
	Algorithm Properties.
	Knowledge.
	Remains Universal.  A universal algorithm is one that will work for what it is intended to work on, regardless of input.  For example if there is a graph and the number of nodes is desired to be found, an algorithm can be created so that every node is counted no matter what shape or size of graph it is.  On the other hand an algorithm that is not universal would not work for any size graph or any shape of graph, there will be limitations to it that cause it to not always work.
[E] 	Experiments:
Added distance to the random graphs.  These graphs with distance will be compared for completion time with the original graphs.  To do this an average sample of completions must be taken in order to eliminate the variance between random generations.  A sample of 20 random graphs has been chosen to represent the population for each test, 20 should be a large enough sample size to get a more accurate/reasonable average outcome for running time.  
Each graph will contain a specific number of nodes per test, the first set of 20 tests will be run on simply 10 nodes in the graph.  When the 20 tests have been completed and times recorded, the same test will be applied to the original graphs and the average can then be compared for a graph of size 10 for a basis.
Next the nodes of the graph will be increased to a number of 50, and the time test will then be run the same way as it was for when there were 10 nodes.  When all the times and averages are calculated for both new and original graphs the averages can be compared again.  An upper limit of time will be instilled to prevent an impossibility result never ending the executions of 10,000 ticks (ticks will simulate 1 second).  Finally the timed tests will be run on graphs with nodes numbering 100 and then compared, Analyzing the data and providing the statistics will continue in the body of this report.

References

[JEA14]  Jérémie Chalopin, Emmanuel Godard and Antoine Naudin. What Do We Need to Know to Elect 	in Networks with Unknown Participants?.  In SIROCCO 2014, page 279-294.


